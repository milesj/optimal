"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4827],{5318:function(e,n,a){a.d(n,{Zo:function(){return d},kt:function(){return m}});var t=a(7378);function i(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function r(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function o(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?r(Object(a),!0).forEach((function(n){i(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function l(e,n){if(null==e)return{};var a,t,i=function(e,n){if(null==e)return{};var a,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||(i[a]=e[a]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)a=r[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=t.createContext({}),p=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):o(o({},n),e)),a},d=function(e){var n=p(e.components);return t.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},c=t.forwardRef((function(e,n){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(a),m=i,h=c["".concat(s,".").concat(m)]||c[m]||u[m]||r;return a?t.createElement(h,o(o({ref:n},d),{},{components:a})):t.createElement(h,o({ref:n},d))}));function m(e,n){var a=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=a.length,o=new Array(r);o[0]=c;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var p=2;p<r;p++)o[p]=a[p];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}c.displayName="MDXCreateElement"},106:function(e,n,a){a.r(n),a.d(n,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return d},default:function(){return c}});var t=a(5773),i=a(808),r=(a(7378),a(5318)),o=["components"],l={title:"Usage"},s=void 0,p={unversionedId:"usage",id:"usage",isDocsHomePage:!1,title:"Usage",description:"Optimal supports individual value validation through reusable schemas, and advanced",source:"@site/docs/usage.md",sourceDirName:".",slug:"/usage",permalink:"/docs/usage",editUrl:"https://github.com/milesj/optimal/edit/master/website/docs/usage.md",tags:[],version:"current",frontMatter:{title:"Usage"},sidebar:"docs",previous:{title:"Introduction",permalink:"/docs/"},next:{title:"Schemas",permalink:"/docs/schemas"}},d=[{value:"Optimal validation",id:"optimal-validation",children:[]},{value:"Schema validation",id:"schema-validation",children:[]},{value:"Default values",id:"default-values",children:[]},{value:"Transforming values",id:"transforming-values",children:[]},{value:"Error messages",id:"error-messages",children:[]},{value:"Nullable fields",id:"nullable-fields",children:[]},{value:"Undefinable fields",id:"undefinable-fields",children:[]},{value:"Required &amp; optional fields",id:"required--optional-fields",children:[]},{value:"Logical operators",id:"logical-operators",children:[]},{value:"Blueprints",id:"blueprints",children:[]}],u={toc:d};function c(e){var n=e.components,a=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,t.Z)({},u,a,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Optimal supports individual value validation through reusable ",(0,r.kt)("a",{parentName:"p",href:"/docs/schemas"},"schemas"),", and advanced\nfunctionality through the ",(0,r.kt)("a",{parentName:"p",href:"#optimal-validation"},(0,r.kt)("inlineCode",{parentName:"a"},"optimal()"))," function. Choose either or both APIs to\nsatisfy your use cases!"),(0,r.kt)("h2",{id:"optimal-validation"},"Optimal validation"),(0,r.kt)("p",null,"The primary API for validating options objects, configuration files, databags, and many more, is\nwith the ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/optimal"},(0,r.kt)("inlineCode",{parentName:"a"},"optimal()"))," function. This function accepts a\n",(0,r.kt)("a",{parentName:"p",href:"#blueprints"},"blueprint")," and an optional ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/OptimalOptions"},"options")," object,\nand returns a schema-like API. Internally this function is a ",(0,r.kt)("a",{parentName:"p",href:"/docs/schemas#shapes"},"shape"),", but it\nprovides additional functionality through options and TypeScript typings."),(0,r.kt)("p",null,"To understand this function, let's demonstrate it with an example. Say we have the following\ninterface and class, and we want to validate the options within the constructor."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"interface PluginOptions {\n    id: string;\n    debug?: boolean;\n    priority?: 'low' | 'normal' | 'high';\n}\n\nclass Plugin {\n    options: PluginOptions;\n\n    constructor(options: PluginOptions) {\n        this.options = options;\n    }\n}\n")),(0,r.kt)("p",null,"We can do this by importing optimal, defining a blueprint, and calling the\n",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/Optimal#validate"},(0,r.kt)("inlineCode",{parentName:"a"},".validate()"))," method. Let's expand upon the example above\nand provide annotations for what's happening."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// Import the optimal function and any schemas we require\nimport { bool, string, optimal } from 'optimal';\n\ninterface PluginOptions {\n    // This field is required\n    id: string;\n    // While these 2 fields are optional\n    debug?: boolean;\n    priority?: 'low' | 'normal' | 'high';\n}\n\nclass Plugin {\n    // We wrap the type in `Required` since optimal ensures they all exist afer validation\n    options: Required<PluginOptions>;\n\n    constructor(options: PluginOptions) {\n        // Instantiate optimal with a blueprint that matches the `PluginOptions` interface\n        this.options = optimal(\n            {\n                // Mark this field as required to match the interface\n                id: string().notEmpty().camelCase().required(),\n                // Omit the required since these 2 fields are optional in the interface\n                debug: bool(),\n                priority: string('low').oneOf(['low', 'normal', 'high']),\n            },\n            {\n                // Provide a unique name within error messages\n                name: this.constructor.name,\n            },\n            // Immediately trigger validation and return a built object!\n        ).validate(options);\n    }\n}\n")),(0,r.kt)("p",null,"Now when the plugin is instantiated, the ",(0,r.kt)("inlineCode",{parentName:"p"},"optimal()")," function will be ran to return an object in the\nshape of the blueprint. For example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// { id: 'abc', debug: false, priority: 'low' }\nnew Plugin({ id: 'abc' }).options;\n\n// { id: 'abc', debug: true, priority: 'low' }\nnew Plugin({ id: 'abc', debug: true }).options;\n\n// { id: 'abc', debug: false, priority: 'high' }\nnew Plugin({ id: 'abc', priority: 'high' }).options;\n\n// Throws an error for invalid `priority` value\nnew Plugin({ id: 'abc', priority: 'severe' }).options;\n\n// Throws an error for an unknown filed\nnew Plugin({ id: 'abc', size: 123 }).options;\n")),(0,r.kt)("h2",{id:"schema-validation"},"Schema validation"),(0,r.kt)("p",null,"Besides ",(0,r.kt)("a",{parentName:"p",href:"#optimal-validation"},(0,r.kt)("inlineCode",{parentName:"a"},"optimal()")),", every schema supports a\n",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/Schema#validate"},(0,r.kt)("inlineCode",{parentName:"a"},".validate()"))," function that can be used to validate and\nreturn a type casted value. ",(0,r.kt)("a",{parentName:"p",href:"/docs/schemas"},"View all available schemas"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { string } from 'optimal';\n\nconst stringSchema = string();\n\nstringSchema.validate(123); // fail\nstringSchema.validate('abc'); // pass\n\n// Or from the instance directly\n\nstring().notEmpty().validate(''); // fail\n")),(0,r.kt)("h2",{id:"default-values"},"Default values"),(0,r.kt)("p",null,"Most schemas support a custom default value when being instantiated, which will be used as a\nfallback when the field is not explicitly defined, or an explicit ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," is passed (unless\n",(0,r.kt)("a",{parentName:"p",href:"#undefinable-fields"},"undefinable"),"). The default value must be the same type as the schema."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const severitySchema = string('low').oneOf(['low', 'high']);\n\nseveritySchema.validate(undefined); // -> low\nseveritySchema.validate('high'); // -> high\n")),(0,r.kt)("p",null,"Furthermore, the default value can also be a function that returns a value. This is useful for\ndeferring execution, or avoiding computation heavy code. This function is passed an object path for\nthe field being validated, the current depth object, and the entire object."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const dateSchema = date(() => new Date(2020, 1, 1));\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"The ",(0,r.kt)("a",{parentName:"p",href:"/docs/schemas#functions"},(0,r.kt)("inlineCode",{parentName:"a"},"func()"))," schema must ",(0,r.kt)("em",{parentName:"p"},"always")," use the factory pattern for defining a\ndefault value, otherwise, the default function will be executed inadvertently.")),(0,r.kt)("h2",{id:"transforming-values"},"Transforming values"),(0,r.kt)("p",null,"All schemas support a chainable ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/CommonCriterias#transform"},(0,r.kt)("inlineCode",{parentName:"a"},"transform()")),"\nmethod that can be used to transform the value. Transformation occurs in place, and ",(0,r.kt)("em",{parentName:"p"},"not")," at the\nbeginning or end of the validation process."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const textSchema = string()\n    // Use smart quotes for typography\n    .transform((value) => value.replace(/'/g, '\u2018').replace(/\"/g, '\u201c'))\n    .notEmpty();\n\ntextSchema.validate(''); // throws\ntextSchema.validate(\"How's it going?\"); // -> How\u2018s it going?\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Multiple tranformations can be declared by chaining multiple ",(0,r.kt)("inlineCode",{parentName:"p"},"transform()"),"s.")),(0,r.kt)("h2",{id:"error-messages"},"Error messages"),(0,r.kt)("p",null,"All failed validations throw an error with descriptive messages for a better user experience.\nHowever, these messages are quite generic to support all scenarios, but can be customized with a\n",(0,r.kt)("inlineCode",{parentName:"p"},"message")," object as the last argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"// throws \"String must be lower cased.\"\nstring().lowerCase().validate('FOO');\n\n// throws \"Please provide a lowercased value.\"\nstring().lowerCase({ message: 'Please provide a lowercased value.' }).validate('FOO');\n")),(0,r.kt)("h2",{id:"nullable-fields"},"Nullable fields"),(0,r.kt)("p",null,"Most schemas are ",(0,r.kt)("em",{parentName:"p"},"not")," nullable by default, which means ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," cannot be returned from a field being\nvalidated. To accept and return ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," values, chain the ",(0,r.kt)("inlineCode",{parentName:"p"},"nullable()")," method on a schema, inversely,\nchain ",(0,r.kt)("inlineCode",{parentName:"p"},"notNullable()")," to ",(0,r.kt)("em",{parentName:"p"},"not")," accept ",(0,r.kt)("inlineCode",{parentName:"p"},"null")," values (resets)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const objectSchema = object().notNullable(); // default\nconst nullableObjectSchema = object().nullable();\n\nobjectSchema.validate(null); // throw error\nnullableObjectSchema.validate(null); // -> null\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"When nullable, the schema's return type is ",(0,r.kt)("inlineCode",{parentName:"p"},"T | null"),".")),(0,r.kt)("h2",{id:"undefinable-fields"},"Undefinable fields"),(0,r.kt)("p",null,"Unlike nullable above, all schemas by default do ",(0,r.kt)("em",{parentName:"p"},"not")," return ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),", as we fallback to the\ndefault value when ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," is passed in. However, they are some scenarios where you want to\nreturn ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),", and when this happens, the default value and most validation criteria is\ncompletely ignored."),(0,r.kt)("p",null,"To accept and return ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," values, chain the ",(0,r.kt)("inlineCode",{parentName:"p"},"undefinable()")," method on a schema, inversely,\nchain ",(0,r.kt)("inlineCode",{parentName:"p"},"notUndefinable()")," to ",(0,r.kt)("em",{parentName:"p"},"not")," accept ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," values (resets)."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const numberSchema = number(123).notUndefinable(); // default\nconst undefinableNumberSchema = number(456).undefinable();\n\nnumberSchema.validate(undefined); // -> 123\nundefinableNumberSchema.validate(undefined); // -> undefined\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"When undefinable, the schema's return type is ",(0,r.kt)("inlineCode",{parentName:"p"},"T | undefined"),".")),(0,r.kt)("h2",{id:"required--optional-fields"},"Required & optional fields"),(0,r.kt)("p",null,"When a schema is marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"required()"),", it requires the field to be explicitly defined and passed\nwhen validating a ",(0,r.kt)("em",{parentName:"p"},"shape"),", otherwise it throws an error. To invert and reset the requirement, use\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"optional()")," method."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const userSchema = shape({\n    name: string().required().notEmpty(),\n    age: number().positive(),\n});\n\nuserSchema.validate({}); // throw error\nuserSchema.validate({ name: 'Bruce Wayne' }); // -> (shape)\n")),(0,r.kt)("p",null,"This ",(0,r.kt)("em",{parentName:"p"},"does not")," change the typing and acceptance of ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," values, it simply checks property\nexistence. Use ",(0,r.kt)("a",{parentName:"p",href:"#undefinable-fields"},"undefinable fields")," for that functionality."),(0,r.kt)("h2",{id:"logical-operators"},"Logical operators"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/docs/schemas#shapes"},"Shapes")," support the AND, OR, and XOR logical operators. When a schema is\nconfigured with these operators and is validated ",(0,r.kt)("em",{parentName:"p"},"outside")," of a shape, they do nothing."),(0,r.kt)("p",null,"When ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/CommonCriterias#and"},(0,r.kt)("inlineCode",{parentName:"a"},"and()"))," is chained on a schema, it requires all\nrelated fields to be defined."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const andSchema = shape({\n    foo: string().and(['bar']),\n    bar: number().and(['foo']),\n});\n\nandSchema.validate({ foo: 'abc' }); // throw error\n\n// Requires both fields to be defined\nandSchema.validate({ foo: 'abc', bar: 123 }); // -> (shape)\n")),(0,r.kt)("p",null,"When ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/CommonCriterias#or"},(0,r.kt)("inlineCode",{parentName:"a"},"or()"))," is chained, it requires 1 or more of the\nfields to be defined."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const orSchema = shape({\n    foo: string().or(['bar', 'baz']),\n    bar: number().or(['foo', 'baz']),\n    baz: bool().or(['foo', 'bar']),\n});\n\norSchema.validate({}); // throw error\n\n// Requires at least 1 field to be defined\norSchema.validate({ foo: 'abc' }); // -> (shape)\norSchema.validate({ bar: 123 }); // -> (shape)\norSchema.validate({ foo: 'abc', baz: true }); // -> (shape)\n")),(0,r.kt)("p",null,"When ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/CommonCriterias#xor"},(0,r.kt)("inlineCode",{parentName:"a"},"xor()"))," is chained, it requires ",(0,r.kt)("em",{parentName:"p"},"only")," 1 of the\nfields to be defined."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const xorSchema = shape({\n    foo: string().xor(['bar', 'baz']),\n    bar: number().xor(['foo', 'baz']),\n    baz: bool().xor(['foo', 'bar']),\n});\n\nxorSchema.validate({}); // throw error\nxorSchema.validate({ foo: 'abc', baz: true }); // throw error\n\n// Requires only 1 field to be defined\nxorSchema.validate({ foo: 'abc' }); // -> (shape)\nxorSchema.validate({ bar: 123 }); // -> (shape)\n")),(0,r.kt)("h2",{id:"blueprints"},"Blueprints"),(0,r.kt)("p",null,"A blueprint is an object of ",(0,r.kt)("a",{parentName:"p",href:"/docs/schemas"},"schemas")," that define an exact structure to be returned\nfrom ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/optimal"},(0,r.kt)("inlineCode",{parentName:"a"},"optimal()"))," and ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/optimal"},(0,r.kt)("inlineCode",{parentName:"a"},"shape()")),".\nEach schema provides a default value to be used when a field of the same name is undefined or\nmissing."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { Blueprint, number, string } from 'optimal';\n\ninterface User {\n    id: number;\n    name: string;\n}\n\nconst user: Blueprint<User> = {\n    id: number().positive(),\n    name: string().notEmpty(),\n};\n")))}c.isMDXComponent=!0}}]);