"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7494],{5318:function(e,a,n){n.d(a,{Zo:function(){return c},kt:function(){return d}});var t=n(7378);function i(e,a,n){return a in e?Object.defineProperty(e,a,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[a]=n,e}function r(e,a){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);a&&(t=t.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),n.push.apply(n,t)}return n}function s(e){for(var a=1;a<arguments.length;a++){var n=null!=arguments[a]?arguments[a]:{};a%2?r(Object(n),!0).forEach((function(a){i(e,a,n[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(n,a))}))}return e}function l(e,a){if(null==e)return{};var n,t,i=function(e,a){if(null==e)return{};var n,t,i={},r=Object.keys(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||(i[n]=e[n]);return i}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(t=0;t<r.length;t++)n=r[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var o=t.createContext({}),p=function(e){var a=t.useContext(o),n=a;return e&&(n="function"==typeof e?e(a):s(s({},a),e)),n},c=function(e){var a=p(e.components);return t.createElement(o.Provider,{value:a},e.children)},m={inlineCode:"code",wrapper:function(e){var a=e.children;return t.createElement(t.Fragment,{},a)}},u=t.forwardRef((function(e,a){var n=e.components,i=e.mdxType,r=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(n),d=i,h=u["".concat(o,".").concat(d)]||u[d]||m[d]||r;return n?t.createElement(h,s(s({ref:a},c),{},{components:n})):t.createElement(h,s({ref:a},c))}));function d(e,a){var n=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var r=n.length,s=new Array(r);s[0]=u;var l={};for(var o in a)hasOwnProperty.call(a,o)&&(l[o]=a[o]);l.originalType=e,l.mdxType="string"==typeof e?e:i,s[1]=l;for(var p=2;p<r;p++)s[p]=n[p];return t.createElement.apply(null,s)}return t.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9629:function(e,a,n){n.r(a),n.d(a,{frontMatter:function(){return l},contentTitle:function(){return o},metadata:function(){return p},toc:function(){return c},default:function(){return u}});var t=n(5773),i=n(808),r=(n(7378),n(5318)),s=["components"],l={title:"Schemas"},o=void 0,p={unversionedId:"schemas",id:"schemas",isDocsHomePage:!1,title:"Schemas",description:"A schema is a factory function that returns a fluent and typed builder interface. This builder can",source:"@site/docs/schemas.md",sourceDirName:".",slug:"/schemas",permalink:"/docs/schemas",editUrl:"https://github.com/milesj/optimal/edit/master/website/docs/schemas.md",tags:[],version:"current",frontMatter:{title:"Schemas"},sidebar:"docs",previous:{title:"Usage",permalink:"/docs/usage"},next:{title:"Predicates",permalink:"/docs/predicates"}},c=[{value:"Arrays",id:"arrays",children:[]},{value:"Blueprints",id:"blueprints",children:[]},{value:"Booleans",id:"booleans",children:[]},{value:"Class instances",id:"class-instances",children:[]},{value:"Custom",id:"custom",children:[]},{value:"Dates",id:"dates",children:[]},{value:"Functions",id:"functions",children:[]},{value:"IDs",id:"ids",children:[]},{value:"Lazy / recursive",id:"lazy--recursive",children:[]},{value:"Numbers",id:"numbers",children:[]},{value:"Objects",id:"objects",children:[]},{value:"Records",id:"records",children:[]},{value:"Regex patterns",id:"regex-patterns",children:[]},{value:"Schemas",id:"schemas",children:[]},{value:"Shapes",id:"shapes",children:[]},{value:"Strings",id:"strings",children:[]},{value:"Tuples",id:"tuples",children:[]},{value:"Unions",id:"unions",children:[]},{value:"UUIDs",id:"uuids",children:[]}],m={toc:c};function u(e){var a=e.components,n=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,t.Z)({},m,n,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"A schema is a factory function that returns a fluent and typed builder interface. This builder can\nbe used to chain validation rules, define a default value, parse values, and more!"),(0,r.kt)("p",null,"All schemas support methods found on the ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/CommonCriterias"},(0,r.kt)("inlineCode",{parentName:"a"},"CommonCriterias")),"\ninterface."),(0,r.kt)("h2",{id:"arrays"},"Arrays"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/array"},(0,r.kt)("inlineCode",{parentName:"a"},"array()"))," schema verifies a value is an array, or an array ",(0,r.kt)("em",{parentName:"p"},"of")," a\nspecific type. For undefined values, an empty array (",(0,r.kt)("inlineCode",{parentName:"p"},"[]"),") is returned, which can be customized with\nthe 1st argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { array, string } from 'optimal';\n\nconst anyArraySchema = array();\n\nanyArraySchema.validate([]); // pass\nanyArraySchema.validate([1, 2, 3]); // pass\nanyArraySchema.validate(['a', 'b', 'c']); // pass\n\nconst stringArraySchema = array(['foo']).of(string()).notEmpty();\n\nstringArraySchema.validate([]); // fail\nstringArraySchema.validate([1, 2, 3]); // fail\nstringArraySchema.validate(['a', 'b', 'c']); // pass\n")),(0,r.kt)("p",null,"Array schemas support all methods found on the ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/ArraySchema"},(0,r.kt)("inlineCode",{parentName:"a"},"ArraySchema")),"\ninterface."),(0,r.kt)("h2",{id:"blueprints"},"Blueprints"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/blueprint"},(0,r.kt)("inlineCode",{parentName:"a"},"blueprint()"))," schema verifies a value is an object that maps\nproperties to schema instances. This schema is useful for composition based APIs."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { blueprint } from 'optimal';\n\nblueprint().validate({\n    name: string(),\n    type: number(),\n});\n")),(0,r.kt)("h2",{id:"booleans"},"Booleans"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/bool"},(0,r.kt)("inlineCode",{parentName:"a"},"bool()"))," schema verifies a value is a boolean. For undefined\nvalues, ",(0,r.kt)("inlineCode",{parentName:"p"},"false")," is returned, which can be customized with the 1st argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { bool } from 'optimal';\n\nconst anyBoolSchema = bool();\n\nanyBoolSchema.validate(true); // pass\nanyBoolSchema.validate(false); // pass\nanyBoolSchema.validate(123); // fail\n\nconst falsyBoolSchema = bool().onlyFalse();\n\nfalsyBoolSchema.validate(true); // fail\nfalsyBoolSchema.validate(false); // pass\n")),(0,r.kt)("p",null,"Boolean schemas support all methods found on the\n",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/BooleanSchema"},(0,r.kt)("inlineCode",{parentName:"a"},"BooleanSchema"))," interface."),(0,r.kt)("h2",{id:"class-instances"},"Class instances"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/instance"},(0,r.kt)("inlineCode",{parentName:"a"},"instance()"))," schema verifies a value is an instance of a\nspecific class (when using ",(0,r.kt)("inlineCode",{parentName:"p"},"of()"),"), or simply an instance of any class (by default). This schema is\nnullable by default and may return ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { instance } from 'optimal';\n\nclass Foo {}\nclass Bar {}\n\nconst anyClassSchema = instance();\n\nanyClassSchema.validate(new Foo()); // pass\nanyClassSchema.validate(new Bar()); // pass\n\nconst fooSchema = instance().of(Foo);\n\nfooSchema.validate(new Foo()); // pass\nfooSchema.validate(new Bar()); // fail\n")),(0,r.kt)("p",null,"Since ",(0,r.kt)("inlineCode",{parentName:"p"},"instanceof")," checks are problematic across realms or when dealing with dual-package hazards,\nan optional ",(0,r.kt)("inlineCode",{parentName:"p"},"loose")," argument can be enabled as the 2nd argument on ",(0,r.kt)("inlineCode",{parentName:"p"},"of()"),". This will compare\nconstructor names, which is brittle, but unblocks certain scenarios."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const looseFooSchema = instance().of(Foo, true);\n")),(0,r.kt)("p",null,"Instance schemas support all methods found on the\n",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/InstanceSchema"},(0,r.kt)("inlineCode",{parentName:"a"},"InstanceSchema"))," interface."),(0,r.kt)("h2",{id:"custom"},"Custom"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/custom"},(0,r.kt)("inlineCode",{parentName:"a"},"custom()"))," schema verifies a value based on a user-provided\ncallback. This callback receives the current value to validate, an object path, and validation\noptions (which includes any root and current objects)."),(0,r.kt)("p",null,"A default value is required as the 2nd argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import path from 'path';\nimport { custom } from 'optimal';\n\nconst absPathSchema = custom((value) => {\n    if (!path.isAbsolute(value)) {\n        throw new Error('Path must be absolute.');\n    }\n}, process.cwd());\n\nabsPathSchema.validate('/absolute/path'); // pass\nabsPathSchema.validate('../relative/path'); // fail\n")),(0,r.kt)("p",null,"Custom schemas support all methods found on the\n",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/CustomSchema"},(0,r.kt)("inlineCode",{parentName:"a"},"CustomSchema"))," interface."),(0,r.kt)("h2",{id:"dates"},"Dates"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/date"},(0,r.kt)("inlineCode",{parentName:"a"},"date()"))," schema verifies a value is date-like, which supports\n",(0,r.kt)("inlineCode",{parentName:"p"},"Date")," objects, an ISO-8601 string, or a UNIX timestamp. Regardless of the input value, a ",(0,r.kt)("inlineCode",{parentName:"p"},"Date"),"\nobject is always returned as the output value. For undefined values, a new ",(0,r.kt)("inlineCode",{parentName:"p"},"Date")," is returned."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { date } from 'optimal';\n\nconst dateSchema = date();\n\ndateSchema.validate(new Date()); // pass\ndateSchema.validate(1632450940763); // pass\ndateSchema.validate('2021-09-24T02:32:31.610Z'); // pass\n")),(0,r.kt)("p",null,"Date schemas support all methods found on the ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/DateSchema"},(0,r.kt)("inlineCode",{parentName:"a"},"DateSchema")),"\ninterface."),(0,r.kt)("h2",{id:"functions"},"Functions"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/func"},(0,r.kt)("inlineCode",{parentName:"a"},"func()"))," schema verifies a value is a function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { func } from 'optimal';\n\nconst funcSchema = func();\n\nfuncSchema.validate(() => {}); // pass\nfuncSchema.validate(123); // fail\n")),(0,r.kt)("p",null,"By default this schema has no default value (returns ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),"), regardless of undefinable state,\nbut this can be customized with the 1st argument. However, because of our\n",(0,r.kt)("a",{parentName:"p",href:"/docs/usage#default-values"},"lazy default values"),', the "default function" must be returned with\nanother function.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { func } from 'optimal';\n\nfunction noop() {}\n\n// Incorrect\nfunc(noop);\n\n// Correct\nfunc(() => noop);\n")),(0,r.kt)("p",null,"Function schemas support all methods found on the\n",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/FunctionSchema"},(0,r.kt)("inlineCode",{parentName:"a"},"FunctionSchema"))," interface."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Functions are special when it comes to handling ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined")," values, because, what would the\ndefault value of a function be?")),(0,r.kt)("h2",{id:"ids"},"IDs"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/id"},(0,r.kt)("inlineCode",{parentName:"a"},"id()"))," schema verifies a value is an auto-incrementing ID, most\ncommonly used for database records. All IDs ",(0,r.kt)("em",{parentName:"p"},"must")," be a positive integer, and will not accept ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),",\n",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { id } from 'optimal';\n\nconst idSchema = id();\n\nidSchema.validate(123); // pass\nidSchema.validate(0); // fail\nidSchema.validate(-123); // fail\nidSchema.validate(null); // fail\n")),(0,r.kt)("p",null,"ID schemas support all methods found on the ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/NumberSchema"},(0,r.kt)("inlineCode",{parentName:"a"},"NumberSchema")),"\ninterface."),(0,r.kt)("h2",{id:"lazy--recursive"},"Lazy / recursive"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/number"},(0,r.kt)("inlineCode",{parentName:"a"},"lazy()"))," schema is useful for declaring deferred evaluation or\nrecursive schemas. When using this pattern, the lazy element ",(0,r.kt)("em",{parentName:"p"},"must")," declare a default value, and\n",(0,r.kt)("em",{parentName:"p"},"must")," never be required."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { lazy, LazySchema, number, shape } from 'optimal';\n\ninterface Node {\n    id: number;\n    child?: Node | null;\n}\n\nconst node: LazySchema<Node> = shape({\n    id: number(),\n    child: lazy(() => node, null).nullable(),\n});\n")),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Because of a limitation in TypeScript, the return type cannot be statically inferred, so you'll\nneed to type the schema variable directly with ",(0,r.kt)("inlineCode",{parentName:"p"},"LazySchema"),".")),(0,r.kt)("h2",{id:"numbers"},"Numbers"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/number"},(0,r.kt)("inlineCode",{parentName:"a"},"number()"))," schema verifies a value is a number. For undefined\nvalues, a ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," is returned, which can be customized with the 1st argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { number } from 'optimal';\n\nconst anyNumberSchema = number();\n\nanyNumberSchema.validate(123); // pass\nanyNumberSchema.validate('abc'); // fail\n\nconst intGteNumberSchema = number(100).int().gte(100);\n\nintGteNumberSchema.validate(150); // pass\nintGteNumberSchema.validate(50); // fail\nintGteNumberSchema.validate(200.25); // fail\n")),(0,r.kt)("p",null,"Number schemas support all methods found on the\n",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/NumberSchema"},(0,r.kt)("inlineCode",{parentName:"a"},"NumberSchema"))," interface."),(0,r.kt)("h2",{id:"objects"},"Objects"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/object"},(0,r.kt)("inlineCode",{parentName:"a"},"object()"))," schema verifies a value is a plain object or an\nindexed object with all values of a specific type. For undefined values, an empty object (",(0,r.kt)("inlineCode",{parentName:"p"},"{}"),") is\nreturned, which can be customized with the 1st argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { object, number } from 'optimal';\n\nconst anyObjectSchema = object();\n\nanyObjectSchema.validate({}); // pass\nanyObjectSchema.validate({ foo: 123 }); // pass\nanyObjectSchema.validate({ bar: 'abc' }); // pass\n\nconst numberObjectSchema = object().of(number());\n\nnumberObjectSchema.validate({ foo: 123 }); // pass\nnumberObjectSchema.validate({ bar: 'abc' }); // fail\n")),(0,r.kt)("p",null,"Objects can also define schemas for keys. For example, say we ",(0,r.kt)("em",{parentName:"p"},"only")," want underscored names."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"object().keysOf(string().snakeCase());\n")),(0,r.kt)("p",null,"Object schemas support all methods found on the\n",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/ObjectSchema"},(0,r.kt)("inlineCode",{parentName:"a"},"ObjectSchema"))," interface."),(0,r.kt)("h2",{id:"records"},"Records"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/record"},(0,r.kt)("inlineCode",{parentName:"a"},"record()"))," schema is an alias for ",(0,r.kt)("a",{parentName:"p",href:"#objects"},"objects"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { record } from 'optimal';\n")),(0,r.kt)("h2",{id:"regex-patterns"},"Regex patterns"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/regex"},(0,r.kt)("inlineCode",{parentName:"a"},"regex()"))," schema verifies a value is an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"RegExp"),".\nThis schema is nullable by default and may return ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { regex } from 'optimal';\n\nconst regexSchema = regex();\n\nregexSchema.validate(/foo/); // pass\nregexSchema.validate(new RegExp('bar')); // pass\nregexSchema.validate('baz'); // fail\n")),(0,r.kt)("p",null,"Regex schemas support all methods found on the\n",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/InstanceSchema"},(0,r.kt)("inlineCode",{parentName:"a"},"InstanceSchema"))," interface."),(0,r.kt)("h2",{id:"schemas"},"Schemas"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/schema"},(0,r.kt)("inlineCode",{parentName:"a"},"schema()"))," schema verifies a value is a schema instance. This is\nuseful for composing blueprints."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { number, schema } from 'optimal';\n\nconst anySchema = schema();\n\nanySchema.validate(number()); // pass\nanySchema.validate({}); // fail\n")),(0,r.kt)("h2",{id:"shapes"},"Shapes"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/shape"},(0,r.kt)("inlineCode",{parentName:"a"},"shape()"))," schema verifies a value matches a explicit object\nshape, defined as a blueprint mapping properties to schemas. For undefined values, defaults to the\nstructure of the shape and ",(0,r.kt)("em",{parentName:"p"},"cannot")," be customized."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { bool, shape, string } from 'optimal';\n\nconst imageSchema = shape({\n    name: string().notEmpty().required(),\n    path: string().required(),\n    type: string('png'),\n    relative: bool(),\n});\n\nimageSchema.validate({\n    name: 'Image',\n    path: '/some/path/image.png',\n    type: 'png',\n    relative: false,\n}); // pass\n\nimageSchema.validate({ name: 'Invalid', size: 123 }); // fail\n")),(0,r.kt)("p",null,"Shape schemas support all methods found on the ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/ShapeSchema"},(0,r.kt)("inlineCode",{parentName:"a"},"ShapeSchema")),"\ninterface."),(0,r.kt)("h2",{id:"strings"},"Strings"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/string"},(0,r.kt)("inlineCode",{parentName:"a"},"string()"))," schema verifies a value is a string. For undefined\nvalues, an empty string (",(0,r.kt)("inlineCode",{parentName:"p"},"''"),") is returned, which can be customized with the 1st argument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { string } from 'optimal';\n\nconst anyStringSchema = string();\n\nanyStringSchema.validate(''); // pass\nanyStringSchema.validate('abc'); // pass\n\nconst fileTypeSchema = string('js').oneOf(['js', 'ts', 'css', 'html']);\n\nfileTypeSchema.validate('js'); // pass\nfileTypeSchema.validate('png'); // fail\n")),(0,r.kt)("h2",{id:"tuples"},"Tuples"),(0,r.kt)("p",null,"A tuple is an array-like structure with a defined set of items, each with their own unique type. The\n",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/tuple"},(0,r.kt)("inlineCode",{parentName:"a"},"tuple()"))," schema will validate each item and return an array of the\nsame length and types. Defaults to the structure of the tuple and ",(0,r.kt)("em",{parentName:"p"},"cannot")," be customized."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { number, string tuple } from 'optimal';\n\ntype Item = [number, string]; // ID, name\n\nconst itemTuple = tuple<Item>([number().gt(0).required(), string().notEmpty()]);\n\nitemTuple.validate([]); // fail\nitemTuple.validate([123]); // pass\nitemTuple.validate([123, 'abc']); // pass\nitemTuple.validate([123, 'abc', true]); // fail\n")),(0,r.kt)("p",null,"Tuple schemas support all methods found on the ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/TupleSchema"},(0,r.kt)("inlineCode",{parentName:"a"},"TupleSchema")),"\ninterface."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"When using TypeScript, a generic type is required for schemas to type correctly. Furthermore, the\nschema only supports a max length of 5 items.")),(0,r.kt)("h2",{id:"unions"},"Unions"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"api/optimal/function/union"},(0,r.kt)("inlineCode",{parentName:"a"},"union()"))," schema verifies a value against a list of possible\nvalues. All unions ",(0,r.kt)("em",{parentName:"p"},"require")," a default value as the 1st argument, as we need a value to fallback to."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { array, string, shape, union } from 'optimal';\n\ntype EntryPoint = string | string[] | { path: string };\n\nconst entryPointSchema = union<EntryPoint>('./src/index.ts').of([\n    string(),\n    array(string()),\n    shape({\n        path: string(),\n    }),\n]);\n\nentryPointSchema.validate('./some/path'); // pass\nentryPointSchema.validate(['./some/path', './another/path']); // pass\nentryPointSchema.validate({ path: './some/path' }); // pass\n")),(0,r.kt)("p",null,"Unions support multiple schemas of the same type in unison, and the first one that passes validation\nwill be used."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { number, string, object, union } from 'optimal';\n\nconst objectOfNumberOrString = union<Record<string, number> | Record<string, string>>({}).of([\n    object(number()),\n    object(string()),\n]);\n")),(0,r.kt)("p",null,"Unions also support objects and shapes in unison. However, when using this approach, be sure that\nshapes are listed first so that they validate their shape early and exit the validation process."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { number, string, object, union } from 'optimal';\n\nconst shapeOrObject = union<{ path: string } | Record<string, number>>({}).of([\n    shape({\n        path: string(),\n    }),\n    object(number()),\n]);\n")),(0,r.kt)("p",null,"Union schemas support all methods found on the ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/UnionSchema"},(0,r.kt)("inlineCode",{parentName:"a"},"UnionSchema")),"\ninterface."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"When using TypeScript, the type cannot be inferred automatically, so defaults to ",(0,r.kt)("inlineCode",{parentName:"p"},"unknown"),". This\ncan be overridden by explicitly defining the generic, as seen in the examples above.")),(0,r.kt)("h2",{id:"uuids"},"UUIDs"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/function/uuid"},(0,r.kt)("inlineCode",{parentName:"a"},"uuid()"))," schema verifies a value is a universally unique\nidentifier, most commonly used for database records. All UUIDs ",(0,r.kt)("em",{parentName:"p"},"must")," be align with the\n",(0,r.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Universally_unique_identifier"},"specification"),", and will not accept an\nempty string (",(0,r.kt)("inlineCode",{parentName:"p"},'""'),"), ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", or ",(0,r.kt)("inlineCode",{parentName:"p"},"undefined"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"import { uuid } from 'optimal';\n\nconst uuidSchema = uuid();\n\nuuidSchema.validate('e023d5bd-5c1b-3b47-8646-cacb8b8e3634'); // pass\nuuidSchema.validate(''); // fail\nuuidSchema.validate(null); // fail\n")),(0,r.kt)("p",null,"By default the schema will validate ",(0,r.kt)("em",{parentName:"p"},"all")," UUID versions, but this can be customized with the 1st\nargument."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"const v4UuidSchema = uuid(4);\n")),(0,r.kt)("p",null,"UUID schemas support all methods found on the ",(0,r.kt)("a",{parentName:"p",href:"/api/optimal/interface/StringSchema"},(0,r.kt)("inlineCode",{parentName:"a"},"StringSchema")),"\ninterface."))}u.isMDXComponent=!0}}]);