declare module 'optimal' {
  declare export type SupportedType =
    'array' | 'boolean' | 'function' | 'instance' | 'number' |
    'object' | 'shape' | 'string' | 'union' | 'custom';

  declare export type Checker = (path: string, value: *, ...args: *[]) => void;

  declare export type CustomCallback = (value: *, options: Object) => void;

  declare export type Blueprint = { [key: string]: Builder<*> | Blueprint };

  declare export type Builders = {
    array: (builder: Builder<*>, defaultValue?: ?*[]) => CollectionBuilder<*, *[]>,
    bool: <T: boolean>(defaultValue?: ?T) => Builder<?T>,
    custom: (callback: CustomCallback, defaultValue?: *) => Builder<*>,
    date: () => InstanceBuilder<Class<Date>>,
    func: <T: Function>(defaultValue?: ?T) => Builder<?T>,
    instance: (refClass: *) => InstanceBuilder<*>,
    number: <T: number>(defaultValue?: ?T) => NumberBuilder<T>,
    object: (builder?: Builder<*>, defaultValue?: ?{ [key: string]: * }) => CollectionBuilder<*, { [key: string]: * }>,
    regex: () => InstanceBuilder<Class<RegExp>>,
    shape: (builders: { [key: string]: Builder<*> }, defaultValue?: ?{ [key: string]: * }) => ShapeBuilder,
    string: <T: string>(defaultValue?: ?T) => StringBuilder<T>,
    union: (builders: Builder<*>[], defaultValue?: *) => UnionBuilder,
  };

  declare export type Factory = (builders: Builders) => Blueprint;

  declare export type Config = {
    name?: string,
    unknown?: boolean,
  };

  declare export class Builder<T> {
    checks: {
      args: *[],
      func: Checker,
    }[];
    currentConfig: Config;
    currentOptions: Object;
    defaultValue: T;
    deprecatedMessage: string;
    errorMessage: string;
    isNullable: boolean;
    isRequired: boolean;
    type: SupportedType;
    constructor(type: SupportedType, defaultValue: T): void;
    addCheck(func: Checker, ...args: *[]): this;
    and(...keys: string[]): this;
    custom(callback: CustomCallback): this;
    deprecate(message: string): this;
    invariant(condition: boolean, message: string, path?: string): void;
    key(path: string): string;
    message(message: string): this;
    nullable(state?: boolean): this;
    only(): this;
    or(...keys: string[]): this;
    required(state?: boolean): this;
    runChecks(path: string, value: *, options: Object, config?: Config): *;
    xor(...keys: string[]): this;
  }

  declare export class CollectionBuilder<T, TDefault> extends Builder<?TDefault> {
    constructor(type: 'array' | 'object', contents?: Builder<T>, defaultValue?: ?TDefault): void;
    notEmpty(): this;
  }

  declare export class InstanceBuilder<T> extends Builder<?T> {
    refClass: T;
    constructor(refClass: T): void;
  }

  declare export class NumberBuilder<T: number> extends Builder<?T> {
    constructor(defaultValue?: ?T): void;
    between(min: number, max: number, inclusive?: boolean): this;
    gt(min: number, inclusive?: boolean): this;
    gte(min: number): this;
    lt(max: number, inclusive?: boolean): this;
    lte(max: number): this;
    oneOf(list: T[]): this;
  }

  declare export class ShapeBuilder extends Builder<?{ [key: string]: * }> {
    constructor(
      contents: { [key: string]: Builder<*> },
      defaultValue?: ?{ [key: string]: * },
    ): void;
  }

  declare export class StringBuilder<T: string> extends Builder<?T> {
    allowEmpty: boolean;
    constructor(defaultValue?: ?T): void;
    contains(token: string, index?: number): this;
    match(pattern: RegExp): this;
    empty(): this;
    oneOf(list: T[]): this;
  }

  declare export class UnionBuilder extends Builder<*> {
    constructor(builders: Builder<*>[], defaultValue?: *): void;
  }

  declare export default function Options(
    baseOptions: Object,
    factory: Factory,
    config?: Config,
  ): Object;
}
